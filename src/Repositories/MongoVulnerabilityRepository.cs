using Microsoft.Extensions.Options;
using MongoDB.Driver;
using TrueSecProject.Data;
using TrueSecProject.Exceptions;
using TrueSecProject.Settings;

namespace TrueSecProject.Repositories
{
    /// <summary>
    /// A repository for managing Vulnerability objects in a MongoDB database.
    /// </summary>
    public class MongoVulnerabilityRepository : IVulnerabilityRepository
    {
        private readonly IMongoCollection<VulnerabilityEntity> _vulnerabilitiesCollection;

        /// <summary>
        /// Initializes a new instance of the MongoVulnerabilityRepository.
        /// </summary>
        /// <param name="mongoClient">The MongoDB client.</param>
        /// <param name="mongoDbSettings">The MongoDB settings containing database and collection names.</param>
        public MongoVulnerabilityRepository(IMongoClient mongoClient, IOptions<MongoDbSettings> mongoDbSettings)
        {
            var database = mongoClient.GetDatabase(mongoDbSettings.Value.DatabaseName);
            _vulnerabilitiesCollection = database.GetCollection<VulnerabilityEntity>(mongoDbSettings.Value.VulnerabilitiesCollectionName);
        }

        public async Task<IEnumerable<VulnerabilityEntity>> GetAllAsync()
        {
            return await _vulnerabilitiesCollection.Find(_ => true).ToListAsync();
        }

        public async Task<VulnerabilityEntity?> GetByIdAsync(string id)
        {
            return await _vulnerabilitiesCollection.Find(v => v.Id == id).FirstOrDefaultAsync();
        }

        public async Task AddAsync(VulnerabilityEntity vulnerability)
        {
            try
            {
                await _vulnerabilitiesCollection.InsertOneAsync(vulnerability);
            }
            catch (MongoWriteException ex) when (ex.WriteError.Category == ServerErrorCategory.DuplicateKey)
            {
                throw new DuplicateException($"A vulnerability with the ID '{vulnerability.Id}' already exists.");
            }
        }

        public async Task<bool> UpdateAsync(VulnerabilityEntity vulnerability)
        {
            var options = new ReplaceOptions { IsUpsert = true };
            var result = await _vulnerabilitiesCollection.ReplaceOneAsync(v => v.Id == vulnerability.Id, vulnerability, options);
            return result.IsAcknowledged && (result.ModifiedCount > 0);
        }

        public async Task<bool> DeleteAsync(string id)
        {
            var result = await _vulnerabilitiesCollection.DeleteOneAsync(v => v.Id == id);
            return result.IsAcknowledged && result.DeletedCount > 0;
        }
    }
}